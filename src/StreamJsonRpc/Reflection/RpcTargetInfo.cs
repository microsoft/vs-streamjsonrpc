// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Runtime.ExceptionServices;
using Microsoft;
using Microsoft.VisualStudio.Threading;
using StreamJsonRpc.Protocol;

namespace StreamJsonRpc.Reflection;

internal class RpcTargetInfo : System.IAsyncDisposable
{
    private const string ImpliedMethodNameAsyncSuffix = "Async";
    private static readonly Dictionary<TypeInfo, MethodNameMap> MethodNameMaps = new Dictionary<TypeInfo, MethodNameMap>();
    private static readonly Dictionary<(TypeInfo Type, bool AllowNonPublicInvocation, bool UseSingleObjectParameterDeserialization, bool ClientRequiresNamedArguments), Dictionary<string, List<MethodSignature>>> RequestMethodToClrMethodMap = new();
    private readonly JsonRpc jsonRpc;

    /// <summary>
    /// A collection of target objects and their map of clr method to <see cref="JsonRpcMethodAttribute"/> values.
    /// </summary>
    private readonly Dictionary<string, List<MethodSignatureAndTarget>> targetRequestMethodToClrMethodMap = new Dictionary<string, List<MethodSignatureAndTarget>>(StringComparer.Ordinal);

    /// <summary>
    /// A list of event handlers we've registered on target objects that define events. May be <see langword="null"/> if there are no handlers.
    /// </summary>
    private List<EventReceiver>? eventReceivers;

    /// <summary>
    /// A lazily-initialized list of objects to dispose of when the JSON-RPC connection drops.
    /// </summary>
    private List<object>? localTargetObjectsToDispose;

    internal RpcTargetInfo(JsonRpc jsonRpc)
    {
        this.jsonRpc = jsonRpc;
    }

    private TraceSource TraceSource => this.jsonRpc.TraceSource;

    private object SyncObject => this.targetRequestMethodToClrMethodMap;

    public async ValueTask DisposeAsync()
    {
        if (this.localTargetObjectsToDispose is object)
        {
            List<Exception>? exceptions = null;
            foreach (object target in this.localTargetObjectsToDispose)
            {
                // We're calling Dispose on the target objects, so switch to the user-supplied SyncContext for those target objects.
                await this.jsonRpc.SynchronizationContextOrDefault;

                try
                {
                    // Arrange to dispose of the target when the connection is closed.
                    if (target is System.IAsyncDisposable asyncDisposableTarget)
                    {
                        await asyncDisposableTarget.DisposeAsync().ConfigureAwait(false);
                    }
                    else if (target is Microsoft.VisualStudio.Threading.IAsyncDisposable vsAsyncDisposableTarget)
                    {
                        await vsAsyncDisposableTarget.DisposeAsync().ConfigureAwait(false);
                    }
                    else if (target is IDisposable disposableTarget)
                    {
                        disposableTarget.Dispose();
                    }
                }
#pragma warning disable CA1031 // Do not catch general exception types
                catch (Exception ex)
#pragma warning restore CA1031 // Do not catch general exception types
                {
                    exceptions ??= new List<Exception>();
                    exceptions.Add(ex);
                }
            }

            if (exceptions is object)
            {
                if (exceptions.Count == 1)
                {
                    ExceptionDispatchInfo.Capture(exceptions[0]).Throw();
                }

                throw new AggregateException(exceptions);
            }
        }
    }

    internal static MethodNameMap GetMethodNameMap(TypeInfo type)
    {
        MethodNameMap? map;
        lock (MethodNameMaps)
        {
            if (MethodNameMaps.TryGetValue(type, out map))
            {
                return map;
            }
        }

        map = new MethodNameMap(type);

        lock (MethodNameMaps)
        {
            if (MethodNameMaps.TryGetValue(type, out MethodNameMap? lostRaceMap))
            {
                return lostRaceMap;
            }

            MethodNameMaps.Add(type, map);
        }

        return map;
    }

    /// <summary>
    /// Gets the <see cref="JsonRpcMethodAttribute"/> for a previously discovered RPC method, if there is one.
    /// </summary>
    /// <param name="methodName">The name of the method for which the attribute is sought.</param>
    /// <param name="parameters">
    /// The list of parameters found on the method, as they may be given to <see cref="JsonRpcRequest.TryGetTypedArguments(ReadOnlySpan{ParameterInfo}, Span{object})"/>.
    /// Note this list may omit some special parameters such as a trailing <see cref="CancellationToken"/>.
    /// </param>
    internal JsonRpcMethodAttribute? GetJsonRpcMethodAttribute(string methodName, ReadOnlySpan<ParameterInfo> parameters)
    {
        lock (this.SyncObject)
        {
            if (this.targetRequestMethodToClrMethodMap.TryGetValue(methodName, out List<MethodSignatureAndTarget>? existingList))
            {
                foreach (MethodSignatureAndTarget entry in existingList)
                {
                    if (entry.Signature.MatchesParametersExcludingCancellationToken(parameters))
                    {
                        return entry.Signature.Attribute;
                    }
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Searches for a method to dispatch an incoming request to.
    /// </summary>
    /// <param name="request">The incoming request.</param>
    /// <param name="targetMethod">Receives information about the search. Check <see cref="TargetMethod.IsFound"/> to see if an exact signature match was found.</param>
    /// <returns>A value indicating whether the requested method name matches any that we accept. Use <see cref="TargetMethod.IsFound"/> on <paramref name="targetMethod"/> to confirm that an exact signature match is found.</returns>
    internal bool TryGetTargetMethod(JsonRpcRequest request, [NotNullWhen(true)] out TargetMethod? targetMethod)
    {
        Requires.Argument(request.Method is object, nameof(request), nameof(JsonRpcRequest.Method) + " must be set.");

        lock (this.SyncObject)
        {
            if (this.targetRequestMethodToClrMethodMap.TryGetValue(request.Method, out List<MethodSignatureAndTarget>? candidateTargets))
            {
                targetMethod = new TargetMethod(request, candidateTargets, this.jsonRpc.SynchronizationContextOrDefault);
                return true;
            }

            targetMethod = null;
            return false;
        }
    }

    /// <summary>
    /// Adds the specified target as possible object to invoke when incoming messages are received.
    /// </summary>
    /// <param name="exposingMembersOn">
    /// The type whose members define the RPC accessible members of the <paramref name="target"/> object.
    /// If this type is not an interface, only public members become invokable unless <see cref="JsonRpcTargetOptions.AllowNonPublicInvocation"/> is set to true on the <paramref name="options"/> argument.
    /// </param>
    /// <param name="target">Target to invoke when incoming messages are received.</param>
    /// <param name="options">A set of customizations for how the target object is registered. If <see langword="null"/>, default options will be used.</param>
    /// <param name="requestRevertOption"><see langword="true"/> to receive an <see cref="IDisposable"/> that can remove the target object; <see langword="false" /> otherwise.</param>
    /// <returns>An object that may be disposed of to revert the addition of the target object. Will be null if and only if <paramref name="requestRevertOption"/> is <see langword="false"/>.</returns>
    /// <remarks>
    /// When multiple target objects are added, the first target with a method that matches a request is invoked.
    /// </remarks>
    internal RevertAddLocalRpcTarget? AddLocalRpcTarget(Type exposingMembersOn, object target, JsonRpcTargetOptions? options, bool requestRevertOption)
    {
        RevertAddLocalRpcTarget? revert = requestRevertOption ? new RevertAddLocalRpcTarget(this) : null;
        options = options ?? JsonRpcTargetOptions.Default;
        IReadOnlyDictionary<string, List<MethodSignature>> mapping = GetRequestMethodToClrMethodMap(exposingMembersOn.GetTypeInfo(), options.AllowNonPublicInvocation, options.UseSingleObjectParameterDeserialization, options.ClientRequiresNamedArguments);

        lock (this.SyncObject)
        {
            this.AddRpcInterfaceToTarget(mapping, target, options, revert);

            if (options.NotifyClientOfEvents)
            {
                HashSet<string>? eventsDiscovered = null;
                IReadOnlyList<EventInfo> events = GetEventInfos(exposingMembersOn.GetTypeInfo());

                foreach (EventInfo evt in events)
                {
                    if (this.eventReceivers is null)
                    {
                        this.eventReceivers = new List<EventReceiver>();
                    }

                    if (eventsDiscovered is null)
                    {
                        eventsDiscovered = new HashSet<string>(StringComparer.Ordinal);
                    }

                    if (!eventsDiscovered.Add(evt.Name))
                    {
                        // Do not add the same event again. It can appear multiple times in a type hierarchy.
                        continue;
                    }

                    if (this.TraceSource.Switch.ShouldTrace(TraceEventType.Information))
                    {
                        this.TraceSource.TraceEvent(TraceEventType.Information, (int)JsonRpc.TraceEvents.LocalEventListenerAdded, "Listening for events from {0}.{1} to raise notification.", target.GetType().FullName, evt.Name);
                    }

                    var eventReceiver = new EventReceiver(this.jsonRpc, target, evt, options);
                    revert?.RecordEventReceiver(eventReceiver);
                    this.eventReceivers.Add(eventReceiver);
                }
            }

            if (options.DisposeOnDisconnect)
            {
                if (this.localTargetObjectsToDispose is null)
                {
                    this.localTargetObjectsToDispose = new List<object>();
                }

                revert?.RecordObjectToDispose(target);
                this.localTargetObjectsToDispose.Add(target);
            }
        }

        return revert;
    }

    /// <summary>
    /// Adds a new RPC interface to an existing target registering additional RPC methods.
    /// </summary>
    /// <param name="exposingMembersOn">The interface type whose members define the RPC accessible members of the <paramref name="target"/> object.</param>
    /// <param name="target">Target to invoke when incoming messages are received.</param>
    /// <param name="options">A set of customizations for how the target object is registered. If <see langword="null"/>, default options will be used.</param>
    /// <param name="revertAddLocalRpcTarget">An optional object that may be disposed of to revert the addition of the target object..</param>
    internal void AddRpcInterfaceToTarget(Type exposingMembersOn, object target, JsonRpcTargetOptions? options, RevertAddLocalRpcTarget? revertAddLocalRpcTarget)
    {
        Requires.Argument(exposingMembersOn.IsInterface, nameof(exposingMembersOn), Resources.AddRpcInterfaceToTargetParameterNotInterface);

        options = options ?? JsonRpcTargetOptions.Default;
        IReadOnlyDictionary<string, List<MethodSignature>> mapping = GetRequestMethodToClrMethodMap(exposingMembersOn.GetTypeInfo(), allowNonPublicInvocation: true, options.UseSingleObjectParameterDeserialization, options.ClientRequiresNamedArguments);

        this.AddRpcInterfaceToTarget(mapping, target, options, revertAddLocalRpcTarget);
    }

    /// <summary>
    /// Adds a handler for an RPC method with a given name.
    /// </summary>
    /// <param name="handler">
    /// The method or delegate to invoke when a matching RPC message arrives.
    /// This method may accept parameters from the incoming JSON-RPC message.
    /// </param>
    /// <param name="target">An instance of the type that defines <paramref name="handler"/> which should handle the invocation.</param>
    /// <param name="methodRpcSettings">
    /// A description for how this method should be treated.
    /// It need not be an attribute that was actually applied to <paramref name="handler"/>.
    /// An attribute will *not* be discovered via reflection on the <paramref name="handler"/>, even if this value is <see langword="null"/>.
    /// </param>
    /// <param name="synchronizationContext">The <see cref="System.Threading.SynchronizationContext"/> to schedule the method invocation on instead of the default one specified by the <see cref="SynchronizationContext"/> property.</param>
    internal void AddLocalRpcMethod(MethodInfo handler, object? target, JsonRpcMethodAttribute? methodRpcSettings, SynchronizationContext? synchronizationContext)
    {
        Requires.NotNull(handler, nameof(handler));
        Requires.Argument(handler.IsStatic == (target is null), nameof(target), Resources.TargetObjectAndMethodStaticFlagMismatch);

        string rpcMethodName = methodRpcSettings?.Name ?? handler.Name;
        lock (this.SyncObject)
        {
            var methodTarget = new MethodSignatureAndTarget(handler, target, methodRpcSettings, synchronizationContext);
            this.TraceLocalMethodAdded(rpcMethodName, methodTarget);
            if (this.targetRequestMethodToClrMethodMap.TryGetValue(rpcMethodName, out List<MethodSignatureAndTarget>? existingList))
            {
                if (existingList.Any(m => m.Signature.Equals(methodTarget.Signature)))
                {
                    throw new InvalidOperationException(Resources.ConflictMethodSignatureAlreadyRegistered);
                }

                existingList.Add(methodTarget);
            }
            else
            {
                this.targetRequestMethodToClrMethodMap.Add(rpcMethodName, new List<MethodSignatureAndTarget> { methodTarget });
            }
        }
    }

    internal void UnregisterEventHandlersFromTargetObjects()
    {
        if (this.eventReceivers is not null)
        {
            foreach (EventReceiver receiver in this.eventReceivers)
            {
                receiver.Dispose();
            }

            this.eventReceivers = null;
        }
    }

    /// <summary>
    /// Gets a dictionary which maps a request method name to its clr method name via <see cref="JsonRpcMethodAttribute" /> value.
    /// </summary>
    /// <param name="exposedMembersOnType">Type to reflect over and analyze its methods.</param>
    /// <param name="allowNonPublicInvocation"><inheritdoc cref="JsonRpcTargetOptions.AllowNonPublicInvocation" path="/summary"/></param>
    /// <param name="useSingleObjectParameterDeserialization"><inheritdoc cref="JsonRpcTargetOptions.UseSingleObjectParameterDeserialization" path="/summary"/></param>
    /// <param name="clientRequiresNamedArguments"><inheritdoc cref="JsonRpcTargetOptions.ClientRequiresNamedArguments" path="/summary"/></param>
    /// <returns>Dictionary which maps a request method name to its clr method name.</returns>
    private static IReadOnlyDictionary<string, List<MethodSignature>> GetRequestMethodToClrMethodMap(TypeInfo exposedMembersOnType, bool allowNonPublicInvocation, bool useSingleObjectParameterDeserialization, bool clientRequiresNamedArguments)
    {
        Requires.NotNull(exposedMembersOnType, nameof(exposedMembersOnType));

        (TypeInfo Type, bool AllowNonPublicInvocation, bool UseSingleObjectParameterDeserialization, bool ClientRequiresNamedArguments) key = (exposedMembersOnType, allowNonPublicInvocation, useSingleObjectParameterDeserialization, clientRequiresNamedArguments);
        Dictionary<string, List<MethodSignature>>? requestMethodToDelegateMap;
        lock (RequestMethodToClrMethodMap)
        {
            if (RequestMethodToClrMethodMap.TryGetValue(key, out requestMethodToDelegateMap))
            {
                return requestMethodToDelegateMap;
            }
        }

        requestMethodToDelegateMap = new Dictionary<string, List<MethodSignature>>(StringComparer.Ordinal);
        var clrMethodToRequestMethodMap = new Dictionary<string, string>(StringComparer.Ordinal);
        var requestMethodToClrMethodNameMap = new Dictionary<string, string>(StringComparer.Ordinal);
        var candidateAliases = new Dictionary<string, string>(StringComparer.Ordinal);

        MethodNameMap mapping = GetMethodNameMap(exposedMembersOnType);

        // We retrieve exposed types differently for interfaces vs. classes
        var typesToMap = new List<TypeInfo>();
        if (exposedMembersOnType.IsInterface)
        {
            Type[] ifaces = exposedMembersOnType.GetInterfaces();
            typesToMap.Capacity = 1 + ifaces.Length;
            typesToMap.Add(exposedMembersOnType.GetTypeInfo());
            foreach (Type iface in ifaces)
            {
                typesToMap.Add(iface.GetTypeInfo());
            }
        }
        else
        {
            for (TypeInfo? t = exposedMembersOnType.GetTypeInfo(); t is not null && t != typeof(object).GetTypeInfo(); t = t.BaseType?.GetTypeInfo())
            {
                typesToMap.Add(t);
            }
        }

        foreach (TypeInfo t in typesToMap)
        {
            // As we enumerate methods, skip accessor methods
            foreach (MethodInfo method in t.DeclaredMethods.Where(m => !m.IsSpecialName))
            {
                if (!key.AllowNonPublicInvocation && !method.IsPublic && !exposedMembersOnType.IsInterface)
                {
                    continue;
                }

                if (mapping.FindIgnoreAttribute(method) is object)
                {
                    if (mapping.FindMethodAttribute(method) is object)
                    {
                        throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.JsonRpcMethodAndIgnoreAttributesFound, method.Name));
                    }

                    continue;
                }

                var requestName = mapping.GetRpcMethodName(method);

                if (!requestMethodToDelegateMap.TryGetValue(requestName, out List<MethodSignature>? methodList))
                {
                    methodList = new List<MethodSignature>();
                    requestMethodToDelegateMap.Add(requestName, methodList);
                }

                // Verify that all overloads of this CLR method also claim the same request method name.
                if (clrMethodToRequestMethodMap.TryGetValue(method.Name, out string? previousRequestNameUse))
                {
                    if (!string.Equals(previousRequestNameUse, requestName, StringComparison.Ordinal))
                    {
                        Requires.Fail(Resources.ConflictingMethodNameAttribute, method.Name, nameof(JsonRpcMethodAttribute), nameof(JsonRpcMethodAttribute.Name));
                    }
                }
                else
                {
                    clrMethodToRequestMethodMap.Add(method.Name, requestName);
                }

                // Verify that all CLR methods that want to use this request method name are overloads of each other.
                if (requestMethodToClrMethodNameMap.TryGetValue(requestName, out string? previousClrNameUse))
                {
                    if (!string.Equals(method.Name, previousClrNameUse, StringComparison.Ordinal))
                    {
                        Requires.Fail(Resources.ConflictingMethodAttributeValue, method.Name, previousClrNameUse, requestName);
                    }
                }
                else
                {
                    requestMethodToClrMethodNameMap.Add(requestName, method.Name);
                }

                JsonRpcMethodAttribute? attribute = mapping.FindMethodAttribute(method);

                if (attribute is null && (key.UseSingleObjectParameterDeserialization || key.ClientRequiresNamedArguments))
                {
                    attribute = new JsonRpcMethodAttribute(null)
                    {
                        UseSingleObjectParameterDeserialization = key.UseSingleObjectParameterDeserialization,
                        ClientRequiresNamedArguments = key.ClientRequiresNamedArguments,
                    };
                }

                // Skip this method if its signature matches one from a derived type we have already scanned.
                MethodSignature methodTarget = new MethodSignature(method, attribute);
                if (methodList.Contains(methodTarget))
                {
                    continue;
                }

                methodList.Add(methodTarget);

                // If no explicit attribute has been applied, and the method ends with Async,
                // register a request method name that does not include Async as well.
                if (attribute?.Name is null && method.Name.EndsWith(ImpliedMethodNameAsyncSuffix, StringComparison.Ordinal))
                {
                    string nonAsyncMethodName = method.Name.Substring(0, method.Name.Length - ImpliedMethodNameAsyncSuffix.Length);
                    if (!candidateAliases.ContainsKey(nonAsyncMethodName))
                    {
                        candidateAliases.Add(nonAsyncMethodName, method.Name);
                    }
                }
            }
        }

        // Now that all methods have been discovered, add the candidate aliases
        // if it would not introduce any collisions.
        foreach (KeyValuePair<string, string> candidateAlias in candidateAliases)
        {
            if (!requestMethodToClrMethodNameMap.ContainsKey(candidateAlias.Key))
            {
                requestMethodToClrMethodNameMap.Add(candidateAlias.Key, candidateAlias.Value);
                requestMethodToDelegateMap[candidateAlias.Key] = requestMethodToDelegateMap[candidateAlias.Value].ToList();
            }
        }

        lock (RequestMethodToClrMethodMap)
        {
            if (RequestMethodToClrMethodMap.TryGetValue(key, out Dictionary<string, List<MethodSignature>>? lostRace))
            {
                return lostRace;
            }

            RequestMethodToClrMethodMap.Add(key, requestMethodToDelegateMap);
        }

        return requestMethodToDelegateMap;
    }

    /// <summary>
    /// Given a type it will extract all events in the type hierarchy. It deals correctly with
    /// interfaces. Note that it will return duplicates if they appear multiple times in the hierarchy.
    /// </summary>
    /// <param name="exposedMembersOnType">Type to reflect over and analyze its events.</param>
    /// <returns>A list of EventInfos found.</returns>
    private static IReadOnlyList<EventInfo> GetEventInfos(TypeInfo exposedMembersOnType)
    {
        List<EventInfo> eventInfos = new List<EventInfo>();

        for (TypeInfo? t = exposedMembersOnType.GetTypeInfo(); t is not null && t != typeof(object).GetTypeInfo(); t = t.BaseType?.GetTypeInfo())
        {
            foreach (EventInfo evt in t.DeclaredEvents)
            {
                if (evt.AddMethod is object && evt.AddMethod.IsPublic && !evt.AddMethod.IsStatic)
                {
                    eventInfos.Add(evt);
                }
            }
        }

        if (exposedMembersOnType.IsInterface)
        {
            Type[] ifaces = exposedMembersOnType.GetInterfaces();
            foreach (Type iface in ifaces)
            {
                foreach (EventInfo evt in iface.GetTypeInfo().DeclaredEvents)
                {
                    if (evt.AddMethod is object && !evt.AddMethod.IsStatic)
                    {
                        eventInfos.Add(evt);
                    }
                }
            }
        }

        return eventInfos;
    }

    /// <summary>
    /// Adds a new RPC interface to an existing target registering RPC methods.
    /// </summary>
    /// <param name="mapping">The methods to bers of the <paramref name="target"/> object.</param>
    /// <param name="target">Target to invoke when incoming messages are received.</param>
    /// <param name="options">A set of customizations for how the target object is registered. If <see langword="null"/>, default options will be used.</param>
    /// <param name="revertAddLocalRpcTarget">An optional object that may be disposed of to revert the addition of the target object.</param>
    private void AddRpcInterfaceToTarget(IReadOnlyDictionary<string, List<MethodSignature>> mapping, object target, JsonRpcTargetOptions options, RevertAddLocalRpcTarget? revertAddLocalRpcTarget)
    {
        lock (this.SyncObject)
        {
            foreach (KeyValuePair<string, List<MethodSignature>> item in mapping)
            {
                string rpcMethodName = options.MethodNameTransform is not null ? options.MethodNameTransform(item.Key) : item.Key;
                Requires.Argument(rpcMethodName is not null, nameof(options), nameof(JsonRpcTargetOptions.MethodNameTransform) + " delegate returned a value that is not a legal RPC method name.");
                bool alreadyExists = this.targetRequestMethodToClrMethodMap.TryGetValue(rpcMethodName, out List<MethodSignatureAndTarget>? existingList);
                if (!alreadyExists)
                {
                    this.targetRequestMethodToClrMethodMap.Add(rpcMethodName, existingList = new List<MethodSignatureAndTarget>());
                }

                // Only add methods that do not have equivalent signatures to what we already have.
                foreach (MethodSignature newMethod in item.Value)
                {
                    if (!alreadyExists || !existingList.Any(e => e.Equals(newMethod)))
                    {
                        var signatureAndTarget = new MethodSignatureAndTarget(newMethod, target, null);
                        this.TraceLocalMethodAdded(rpcMethodName, signatureAndTarget);
                        revertAddLocalRpcTarget?.RecordMethodAdded(rpcMethodName, signatureAndTarget);
                        existingList!.Add(signatureAndTarget);
                    }
                    else
                    {
                        if (this.TraceSource.Switch.ShouldTrace(TraceEventType.Information))
                        {
                            this.TraceSource.TraceEvent(TraceEventType.Information, (int)JsonRpc.TraceEvents.LocalMethodAdded, "Skipping local RPC method \"{0}\" -> {1} because a method with a colliding signature has already been added.", rpcMethodName, newMethod);
                        }
                    }
                }
            }
        }
    }

    private void TraceLocalMethodAdded(string rpcMethodName, MethodSignatureAndTarget targetMethod)
    {
        Requires.NotNullOrEmpty(rpcMethodName, nameof(rpcMethodName));

        if (this.TraceSource.Switch.ShouldTrace(TraceEventType.Information))
        {
            this.TraceSource.TraceEvent(TraceEventType.Information, (int)JsonRpc.TraceEvents.LocalMethodAdded, "Added local RPC method \"{0}\" -> {1}", rpcMethodName, targetMethod);
        }
    }

    internal class MethodNameMap
    {
        private readonly ReadOnlyMemory<InterfaceMapping> interfaceMaps;
        private readonly Dictionary<MethodInfo, JsonRpcMethodAttribute?> methodAttributes = new Dictionary<MethodInfo, JsonRpcMethodAttribute?>();
        private readonly Dictionary<MethodInfo, JsonRpcIgnoreAttribute?> ignoreAttributes = new Dictionary<MethodInfo, JsonRpcIgnoreAttribute?>();

        internal MethodNameMap(TypeInfo typeInfo)
        {
            Requires.NotNull(typeInfo, nameof(typeInfo));
            this.interfaceMaps = typeInfo.IsInterface ? default
                : typeInfo.ImplementedInterfaces.Select(typeInfo.GetInterfaceMap).ToArray();
        }

        internal string GetRpcMethodName(MethodInfo method)
        {
            Requires.NotNull(method, nameof(method));

            return this.FindMethodAttribute(method)?.Name ?? method.Name;
        }

        /// <summary>
        /// Get the <see cref="JsonRpcMethodAttribute"/>, which may appear on the method itself or the interface definition of the method where applicable.
        /// </summary>
        /// <param name="method">The method to search for the attribute.</param>
        /// <returns>The attribute, if found.</returns>
        internal JsonRpcMethodAttribute? FindMethodAttribute(MethodInfo method)
        {
            Requires.NotNull(method, nameof(method));

            JsonRpcMethodAttribute? attribute;
            lock (this.methodAttributes)
            {
                if (this.methodAttributes.TryGetValue(method, out attribute))
                {
                    return attribute;
                }
            }

            attribute = (JsonRpcMethodAttribute?)method.GetCustomAttribute(typeof(JsonRpcMethodAttribute))
                ?? (JsonRpcMethodAttribute?)this.FindMethodOnInterface(method)?.GetCustomAttribute(typeof(JsonRpcMethodAttribute));

            lock (this.methodAttributes)
            {
                this.methodAttributes[method] = attribute;
            }

            return attribute;
        }

        /// <summary>
        /// Get the <see cref="JsonRpcIgnoreAttribute"/>, which may appear on the method itself or the interface definition of the method where applicable.
        /// </summary>
        /// <param name="method">The method to search for the attribute.</param>
        /// <returns>The attribute, if found.</returns>
        internal JsonRpcIgnoreAttribute? FindIgnoreAttribute(MethodInfo method)
        {
            Requires.NotNull(method, nameof(method));

            JsonRpcIgnoreAttribute? attribute;
            lock (this.ignoreAttributes)
            {
                if (this.ignoreAttributes.TryGetValue(method, out attribute))
                {
                    return attribute;
                }
            }

            attribute = (JsonRpcIgnoreAttribute?)method.GetCustomAttribute(typeof(JsonRpcIgnoreAttribute))
                ?? (JsonRpcIgnoreAttribute?)this.FindMethodOnInterface(method)?.GetCustomAttribute(typeof(JsonRpcIgnoreAttribute));

            lock (this.ignoreAttributes)
            {
                this.ignoreAttributes[method] = attribute;
            }

            return attribute;
        }

        private MethodInfo? FindMethodOnInterface(MethodInfo methodImpl)
        {
            Requires.NotNull(methodImpl, nameof(methodImpl));

            for (int i = 0; i < this.interfaceMaps.Length; i++)
            {
                InterfaceMapping map = this.interfaceMaps.Span[i];
                int methodIndex = Array.IndexOf(map.TargetMethods, methodImpl);
                if (methodIndex >= 0)
                {
                    return map.InterfaceMethods[methodIndex];
                }
            }

            return null;
        }
    }

    /// <summary>
    /// A class whose disposal will revert certain effects of a prior call to <see cref="AddLocalRpcTarget(Type, object, JsonRpcTargetOptions?, bool)"/>.
    /// </summary>
    internal class RevertAddLocalRpcTarget : IDisposable
    {
        private readonly RpcTargetInfo owner;
        private object? objectToDispose;
        private List<(string RpcMethodName, MethodSignatureAndTarget Method)>? targetMethods;
        private List<IDisposable>? eventReceivers;

        internal RevertAddLocalRpcTarget(RpcTargetInfo owner)
        {
            this.owner = owner;
        }

        public void Dispose()
        {
            lock (this.owner.SyncObject)
            {
                if (this.objectToDispose is object)
                {
                    this.owner.localTargetObjectsToDispose?.Remove(this.objectToDispose);
                }

                if (this.targetMethods is object)
                {
                    foreach ((string RpcMethodName, MethodSignatureAndTarget Method) targetMethod in this.targetMethods)
                    {
                        if (this.owner.targetRequestMethodToClrMethodMap.TryGetValue(targetMethod.RpcMethodName, out List<MethodSignatureAndTarget>? list))
                        {
                            list.Remove(targetMethod.Method);
                        }
                    }
                }

                if (this.eventReceivers is object && this.owner.eventReceivers is object)
                {
                    foreach (EventReceiver eventReceiver in this.eventReceivers)
                    {
                        this.owner.eventReceivers.Remove(eventReceiver);
                        eventReceiver.Dispose();
                    }
                }

                this.objectToDispose = null;
                this.targetMethods = null;
                this.eventReceivers = null;
            }
        }

        internal void RecordEventReceiver(IDisposable eventReceiver)
        {
            if (this.eventReceivers is null)
            {
                this.eventReceivers = new List<IDisposable>();
            }

            this.eventReceivers.Add(eventReceiver);
        }

        internal void RecordMethodAdded(string rpcMethodName, MethodSignatureAndTarget newMethod)
        {
            if (this.targetMethods is null)
            {
                this.targetMethods = new List<(string RpcMethodName, MethodSignatureAndTarget Method)>();
            }

            this.targetMethods.Add((rpcMethodName, newMethod));
        }

        internal void RecordObjectToDispose(object target)
        {
            Assumes.Null(this.objectToDispose);
            this.objectToDispose = target;
        }
    }

    private class EventReceiver : IDisposable
    {
        private static readonly MethodInfo OnEventRaisedMethodInfo = typeof(EventReceiver).GetTypeInfo().DeclaredMethods.Single(m => m.Name == nameof(OnEventRaised));
        private static readonly MethodInfo OnEventRaisedGenericMethodInfo = typeof(EventReceiver).GetTypeInfo().DeclaredMethods.Single(m => m.Name == nameof(OnEventRaisedGeneric));
        private readonly JsonRpc jsonRpc;
        private readonly object server;
        private readonly EventInfo eventInfo;
        private readonly Delegate registeredHandler;
        private readonly string rpcEventName;

        internal EventReceiver(JsonRpc jsonRpc, object server, EventInfo eventInfo, JsonRpcTargetOptions options)
        {
            Requires.NotNull(jsonRpc, nameof(jsonRpc));
            Requires.NotNull(server, nameof(server));
            Requires.NotNull(eventInfo, nameof(eventInfo));

            options = options ?? JsonRpcTargetOptions.Default;

            this.jsonRpc = jsonRpc;
            this.server = server;
            this.eventInfo = eventInfo;

            this.rpcEventName = options.EventNameTransform is not null ? options.EventNameTransform(eventInfo.Name) : eventInfo.Name;

            try
            {
                // This might throw if our EventHandler-modeled method doesn't "fit" the event delegate signature.
                // It will work for EventHandler and EventHandler<T>, at least.
                // If we want to support more, we'll likely have to use lightweight code-gen to generate a method
                // with the right signature.
                ParameterInfo[] eventHandlerParameters = eventInfo.EventHandlerType!.GetTypeInfo().GetMethod("Invoke")!.GetParameters();
                if (eventHandlerParameters.Length != 2)
                {
                    throw new NotSupportedException($"Unsupported event handler type for: \"{eventInfo.Name}\". Expected 2 parameters but had {eventHandlerParameters.Length}.");
                }

                Type argsType = eventHandlerParameters[1].ParameterType;
                if (typeof(EventArgs).GetTypeInfo().IsAssignableFrom(argsType))
                {
                    this.registeredHandler = OnEventRaisedMethodInfo.CreateDelegate(eventInfo.EventHandlerType!, this);
                }
                else
                {
                    MethodInfo closedGenericMethod = OnEventRaisedGenericMethodInfo.MakeGenericMethod(argsType);
                    this.registeredHandler = closedGenericMethod.CreateDelegate(eventInfo.EventHandlerType!, this);
                }
            }
            catch (ArgumentException ex)
            {
                throw new NotSupportedException("Unsupported event handler type for: " + eventInfo.Name, ex);
            }

            eventInfo.AddEventHandler(server, this.registeredHandler);
        }

        public void Dispose()
        {
            this.eventInfo.RemoveEventHandler(this.server, this.registeredHandler);
        }

#pragma warning disable CA1801 // Review unused parameters
        private void OnEventRaisedGeneric<T>(object? sender, T args)
#pragma warning restore CA1801 // Review unused parameters
        {
            this.jsonRpc.NotifyAsync(this.rpcEventName, arguments: new object?[] { args }, argumentDeclaredTypes: new Type[] { typeof(T) }).Forget();
        }

        private void OnEventRaised(object? sender, EventArgs args)
        {
            this.jsonRpc.NotifyAsync(this.rpcEventName, new object[] { args }).Forget();
        }
    }
}
