<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MustBeListening" xml:space="preserve">
    <value>Listening must be started first.</value>
  </data>
  <data name="BothReadableWritableAreNull" xml:space="preserve">
    <value>Both readable and writable are null.</value>
  </data>
  <data name="ConflictingMethodAttributeValue" xml:space="preserve">
    <value>.NET methods '{0}' and '{1}' cannot both map to the same request method name: '{2}'.</value>
    <comment>{0} is the first method name, {1} is the second method name, {2} is the attribute property value.</comment>
  </data>
  <data name="ConflictingMethodNameAttribute" xml:space="preserve">
    <value>All overloads and overrides of the '{0}' method must share a common value for {1}.{2}.</value>
    <comment>{0} is the method name, {1} is the attribute name, {2} is the attribute property name.</comment>
  </data>
  <data name="ConflictMethodSignatureAlreadyRegistered" xml:space="preserve">
    <value>A method with the same name and equivalent parameters has already been registered.</value>
  </data>
  <data name="DroppingRequestDueToNoTargetObject" xml:space="preserve">
    <value>Got a request to execute '{0}' but have no callback object. Dropping the request.</value>
    <comment>{0} is the method name to execute.</comment>
  </data>
  <data name="ErrorWritingJsonRpcResult" xml:space="preserve">
    <value>Error writing JSON RPC Result: {0}: {1}</value>
    <comment>{0} is the exception type, {1} is the exception message.</comment>
  </data>
  <data name="FailureDeserializingJsonRpc" xml:space="preserve">
    <value>Failure deserializing incoming JSON RPC '{0}': {1}</value>
    <comment>{0} is the JSON RPC, {1} is the exception message.</comment>
  </data>
  <data name="FillBufferFirst" xml:space="preserve">
    <value>The buffer is empty. Call the async method to fill it first.</value>
  </data>
  <data name="HeaderContentLengthNotParseable" xml:space="preserve">
    <value>Failed parsing Content-Length header into a positive integer.</value>
    <comment>{locked="Content-Length"}</comment>
  </data>
  <data name="HeaderValueTooLarge" xml:space="preserve">
    <value>The size of the message header exceeds the maximum supported size.</value>
  </data>
  <data name="InvalidAfterListenHasStarted" xml:space="preserve">
    <value>This operation is not allowed after listening for messages has started.</value>
  </data>
  <data name="InvalidBeforeListenHasStarted" xml:space="preserve">
    <value>This operation is not allowed before listening for messages has started.</value>
  </data>
  <data name="JsonRpcCannotBeNull" xml:space="preserve">
    <value>JSON RPC must not be null.</value>
  </data>
  <data name="MethodHasRefOrOutParameters" xml:space="preserve">
    <value>{0} has ref or out parameter(s), which is not supported</value>
    <comment>{0} is the method signature.</comment>
  </data>
  <data name="MethodParameterCountDoesNotMatch" xml:space="preserve">
    <value>{0} parameter(s) (excluding any CancellationToken): {1}, but the request supplies {2}</value>
    <comment>{0} is the method signature, {1} is the method parameter count, {2} is the request parameter count.</comment>
  </data>
  <data name="MethodParametersNotCompatible" xml:space="preserve">
    <value>{0} parameters are not compatible with the arguments provided in the request.</value>
    <comment>{0} is the method signature.</comment>
  </data>
  <data name="NonNegativeIntegerRequired" xml:space="preserve">
    <value>A non-negative integer is required.</value>
  </data>
  <data name="ParameterNotObject" xml:space="preserve">
    <value>Parameter is not in the form of a single object</value>
  </data>
  <data name="PositiveIntegerRequired" xml:space="preserve">
    <value>A positive integer is required.</value>
  </data>
  <data name="ReachedEndOfStream" xml:space="preserve">
    <value>Reached end of stream.</value>
  </data>
  <data name="ReadingJsonRpcStreamFailed" xml:space="preserve">
    <value>Reading JSON RPC from the stream failed with {0}: {1}</value>
    <comment>{0} is the exception type, {1} is the exception message.</comment>
  </data>
  <data name="ResponseIsNotError" xml:space="preserve">
    <value>Response is not error.</value>
  </data>
  <data name="RpcMethodNameNotFound" xml:space="preserve">
    <value>No method by the name '{0}' is found.</value>
  </data>
  <data name="StreamDisposed" xml:space="preserve">
    <value>Stream has been disposed</value>
  </data>
  <data name="StreamMustBeReadable" xml:space="preserve">
    <value>The stream must be readable.</value>
    <comment>An error message when a stream passed in as an argument is incorrect.</comment>
  </data>
  <data name="StreamMustBeWriteable" xml:space="preserve">
    <value>The stream must be writeable.</value>
    <comment>An error message when a stream passed in as an argument is incorrect.</comment>
  </data>
  <data name="SumOfTwoParametersExceedsArrayLength" xml:space="preserve">
    <value>The {0} and {1} parameters exceed length of array.</value>
  </data>
  <data name="TaskNotCompleted" xml:space="preserve">
    <value>The task is not completed.</value>
  </data>
  <data name="TaskWasCancelled" xml:space="preserve">
    <value>The task was cancelled.</value>
  </data>
  <data name="UnableToFindMethod" xml:space="preserve">
    <value>Unable to find method '{0}/{1}' on {2} for the following reasons: {3}</value>
    <comment>{0} is the method name, {1} is arity, {2} is target class full name, {3} is the error list.</comment>
  </data>
  <data name="UnexpectedErrorProcessingJsonRpc" xml:space="preserve">
    <value>Unexpected error processing JSON-RPC message: {0}</value>
    <comment>{0} is the exception message.</comment>
  </data>
  <data name="UnexpectedTokenReadingHeader" xml:space="preserve">
    <value>Unexpected token '{0}' while parsing header.</value>
    <comment>{0} is the token, which is typically a single character.</comment>
  </data>
  <data name="UnrecognizedIncomingJsonRpc" xml:space="preserve">
    <value>Incoming JSON-RPC message did not conform to a recognized pattern.</value>
  </data>
  <data name="TargetObjectAndMethodStaticFlagMismatch" xml:space="preserve">
    <value>A target object should be supplied if and only if the method is not static.</value>
    <comment>"static" is a C# keyword and should not be translated.</comment>
  </data>
  <data name="FatalExceptionWasThrown" xml:space="preserve">
    <value>A fatal exception was thrown from the server method {0}: {1}</value>
    <comment>{0} is the exception type, {1} is the exception message</comment>
  </data>
  <data name="MustNotBeListening" xml:space="preserve">
    <value>This cannot be done after listening has started.</value>
  </data>
  <data name="ClientProxyTypeArgumentMustBeAnInterface" xml:space="preserve">
    <value>"{0}" is not an interface.</value>
  </data>
  <data name="UnsupportedEventHandlerTypeOnClientProxyInterface" xml:space="preserve">
    <value>Unsupported event handler type on "{0}". Only EventHandler and EventHandler&lt;T&gt; are supported.</value>
    <comment>{0} is a type and member name.</comment>
  </data>
  <data name="UnsupportedGenericMethodsOnClientProxyInterface" xml:space="preserve">
    <value>Generic methods are not supported.</value>
  </data>
  <data name="UnsupportedMethodReturnTypeOnClientProxyInterface" xml:space="preserve">
    <value>Method "{0}" has unsupported return type "{1}". Only Task-returning methods are supported.</value>
  </data>
  <data name="UnsupportedPropertiesOnClientProxyInterface" xml:space="preserve">
    <value>Properties are not supported for service interfaces.</value>
  </data>
  <data name="TextEncoderNotApplicable" xml:space="preserve">
    <value>Text encoding is not supported because the formatter "{0}" does not implement "{1}".</value>
    <comment>{0} and {1} are CLR type names.</comment>
  </data>
  <data name="ConnectionDropped" xml:space="preserve">
    <value>The JSON-RPC connection with the remote party was lost before the request could complete.</value>
  </data>
</root>