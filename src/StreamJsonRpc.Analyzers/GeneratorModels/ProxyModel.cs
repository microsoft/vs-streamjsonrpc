// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;

namespace StreamJsonRpc.Analyzers.GeneratorModels;

internal record ProxyModel : FormattableModel
{
    private readonly ImmutableEquatableArray<FormattableModel> formattableElements;

    internal ProxyModel(ImmutableEquatableSet<InterfaceModel> interfaces)
    {
        if (interfaces.Count == 0)
        {
            throw new ArgumentException("Must include at least one interface.", nameof(interfaces));
        }

        this.Interfaces = interfaces;
        string name = CreateProxyName(interfaces);
        this.Name = $"{name.Replace('.', '_')}_Proxy";
        this.FileName = $"{name.Replace('<', '_').Replace('>', '_')}.g.cs";

        int methodSuffix = 0;
        this.formattableElements = this.Interfaces.SelectMany(i => i.Methods).Concat<FormattableModel>(
            this.Interfaces.SelectMany(i => i.Events)).Distinct()
            .Select(e => e is MethodModel method ? method with { UniqueSuffix = ++methodSuffix } : e)
            .ToImmutableEquatableArray();
    }

    internal ImmutableEquatableSet<InterfaceModel> Interfaces { get; }

    internal string Name { get; }

    internal string FileName { get; }

    internal void GenerateSource(SourceProductionContext context)
    {
        // TODO: consider declaring the proxy type with equivalent visibility as the interface,
        //       since a public interface needs a publicly accessible proxy.
        //       Otherwise Reflection is required to access the type.
        SourceWriter writer = new();
        writer.WriteLine("""
            // <auto-generated/>

            #nullable enable

            """);

        // If this proxy is only for a single interface *and* the interface is in the same assembly as the proxy,
        // emit a mapping attribute to help us find the proxy type at runtime.
        if (this.Interfaces.Count == 1 && this.Interfaces.Single() is { DeclaredInThisCompilation: true } onlyIface)
        {
            writer.WriteLine($$""""
                #pragma warning disable CS0436 // Prefer local types to imported ones
                [assembly: global::StreamJsonRpc.Reflection.RpcProxyMappingAttribute(typeof({{onlyIface.InterfaceName}}), typeof({{ProxyGenerator.GenerationNamespace}}.{{this.Name}}))]
                #pragma warning restore CS0436

                """");
        }

        writer.WriteLine($$"""
            namespace {{ProxyGenerator.GenerationNamespace}};

            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyFileVersion}}")]
            internal class {{this.Name}} : global::StreamJsonRpc.Reflection.ProxyBase
            """);

        writer.Indentation++;
        foreach (InterfaceModel iface in this.Interfaces)
        {
            writer.WriteLine($", global::{iface.InterfaceName}");
        }

        writer.Indentation--;
        writer.WriteLine("""
                {
                """);

        writer.Indentation++;
        this.WriteFields(writer);

        this.WriteConstructor(writer);

        this.WriteEvents(writer);
        this.WriteProperties(writer);
        this.WriteMethods(writer);
        this.WriteNestedTypes(writer);

        writer.Indentation--;

        writer.WriteLine("}");

        context.AddSource(this.FileName, writer.ToSourceText());
    }

    internal override void WriteEvents(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteEvents(writer);
        }
    }

    internal override void WriteHookupStatements(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteHookupStatements(writer);
        }
    }

    internal override void WriteMethods(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteMethods(writer);
        }
    }

    internal override void WriteFields(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteFields(writer);
        }
    }

    internal override void WriteProperties(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteProperties(writer);
        }
    }

    internal override void WriteNestedTypes(SourceWriter writer)
    {
        foreach (FormattableModel formattable in this.formattableElements)
        {
            formattable.WriteNestedTypes(writer);
        }
    }

    private void WriteConstructor(SourceWriter writer)
    {
        writer.WriteLine($$"""

                public {{this.Name}}(global::StreamJsonRpc.JsonRpc client, global::StreamJsonRpc.JsonRpcProxyOptions? options, long? marshaledObjectHandle, global::System.Action? onDispose)
                    : base(client, options, marshaledObjectHandle, onDispose)
                {
                """);

        writer.Indentation++;
        this.WriteHookupStatements(writer);

        writer.Indentation--;
        writer.WriteLine("""
                }
                """);
    }

    private static string CreateProxyName(ImmutableEquatableSet<InterfaceModel> interfaces)
    {
        // We need to create a unique, deterministic name given the set of interfaces the proxy must implement.
        if (interfaces.Count == 1)
        {
            // If there's just one, keep it simple.
            return interfaces.Single().InterfaceName;
        }

        // More than one, start by sorting them. Then use the full interface name of the first element, and hash the rest.
        string[] sorted = [.. interfaces.Select(i => i.InterfaceName)];
        Array.Sort(sorted, StringComparer.Ordinal);

        using SHA256 sha = SHA256.Create();
        StringBuilder builder = new();
        for (int i = 1; i < sorted.Length; i++)
        {
            builder.AppendLine(sorted[i]);
        }

        byte[] additionalInterfaceBytes = Encoding.UTF8.GetBytes(builder.ToString());
        byte[] additionalInterfaceHash = sha.ComputeHash(additionalInterfaceBytes);
        string additionalInterfaceHashString = Convert.ToBase64String(additionalInterfaceHash).TrimEnd('=').Replace('+', '_').Replace('/', '_');
        return $"{sorted[0]}{additionalInterfaceHashString[..8]}";
    }
}
