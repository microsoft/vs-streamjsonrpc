// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;

namespace StreamJsonRpc.Analyzers.GeneratorModels;

internal record ProxyModel
{
    internal ProxyModel(ImmutableEquatableArray<InterfaceModel> interfaces)
    {
        if (interfaces.Length == 0)
        {
            throw new ArgumentException("Must include at least one interface.", nameof(interfaces));
        }

        this.Interfaces = interfaces;
        string name = CreateProxyName(interfaces);
        this.Name = $"{name.Replace('.', '_')}_Proxy";
        this.FileName = $"{name}.g.cs";
    }

    internal ImmutableEquatableArray<InterfaceModel> Interfaces { get; }

    internal string Name { get; }

    internal string FileName { get; }

    internal void GenerateSource(SourceProductionContext context)
    {
        // TODO: consider declaring the proxy type with equivalent visibility as the interface,
        //       since a public interface needs a publicly accessible proxy.
        //       Otherwise Reflection is required to access the type.
        SourceWriter writer = new();
        writer.WriteLine($$"""
                // <auto-generated/>

                #nullable enable

                namespace {{ProxyGenerator.GenerationNamespace}};

                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyFileVersion}}")]
                internal class {{this.Name}} : global::StreamJsonRpc.Reflection.ProxyBase
                """);

        writer.Indentation++;
        foreach (InterfaceModel iface in this.Interfaces)
        {
            writer.WriteLine($", global::{iface.InterfaceName}");
        }

        writer.Indentation--;
        writer.WriteLine("""
                {
                """);

        writer.Indentation++;
        foreach (InterfaceModel iface in this.Interfaces)
        {
            iface.WriteFields(writer, iface);
        }

        this.WriteConstructor(writer);

        foreach (InterfaceModel iface in this.Interfaces)
        {
            iface.WriteEvents(writer, iface);
            iface.WriteProperties(writer, iface);
            iface.WriteMethods(writer, iface);
            iface.WriteNestedTypes(writer, iface);
        }

        writer.Indentation--;

        writer.WriteLine("}");

        context.AddSource(this.FileName, writer.ToSourceText());
    }

    private void WriteConstructor(SourceWriter writer)
    {
        writer.WriteLine($$"""

                public {{this.Name}}(global::StreamJsonRpc.JsonRpc client, global::StreamJsonRpc.JsonRpcProxyOptions? options, long? marshaledObjectHandle, global::System.Action? onDispose)
                    : base(client, options, marshaledObjectHandle, onDispose)
                {
                """);

        writer.Indentation++;
        foreach (InterfaceModel iface in this.Interfaces)
        {
            iface.WriteHookupStatements(writer, iface);
        }

        writer.Indentation--;
        writer.WriteLine("""
                }
                """);
    }

    private static string CreateProxyName(ImmutableEquatableArray<InterfaceModel> interfaces)
    {
        // We need to create a unique, deterministic name given the set of interfaces the proxy must implement.
        if (interfaces is [{ } iface])
        {
            // If there's just one, keep it simple.
            return iface.InterfaceName;
        }

        // More than one, start by sorting them. Then use the full interface name of the first element, and hash the rest.
        string[] sorted = [.. interfaces.Select(i => i.InterfaceName)];
        Array.Sort(sorted, StringComparer.Ordinal);

        using SHA256 sha = SHA256.Create();
        StringBuilder builder = new();
        for (int i = 1; i <= sorted.Length; i++)
        {
            builder.AppendLine(sorted[i]);
        }

        string hash = Convert.ToBase64String(Encoding.UTF8.GetBytes(builder.ToString())).Replace('+', '_').Replace('/', '_');
        return $"{sorted[0]}{hash[..8]}";
    }
}
