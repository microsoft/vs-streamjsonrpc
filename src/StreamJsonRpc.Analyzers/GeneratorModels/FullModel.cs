// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using Microsoft.CodeAnalysis;
using StreamJsonRpc.Analyzers;

namespace StreamJsonRpc.Analyzers.GeneratorModels;

internal record FullModel
{
    internal FullModel(ImmutableEquatableSet<ProxyModel> proxies, ImmutableEquatableArray<AttachUse> attachUses, bool publicProxies, bool interceptorsEnabled)
    {
        // Generate a proxy for attributed interfaces in this assembly, and for interfaces used by Attach methods.
        this.Proxies = [.. proxies.Concat(attachUses.Where(a => a.Contracts is not null).Select(a => new ProxyModel(a.Contracts!, a.ExternalProxyName))).Distinct()];

        if (interceptorsEnabled)
        {
            this.Interceptions = [..
                from use in attachUses
                group use by (use.Contracts, use.Signature, use.ExternalProxyName) into attachByProxy
                let proxy = attachByProxy.Key.Contracts is null ? null : new ProxyModel(attachByProxy.Key.Contracts, attachByProxy.Key.ExternalProxyName)
                select new InterceptionModel(proxy, attachByProxy.Key.Signature, [.. from attach in attachByProxy select attach.InterceptableLocation])];
        }

        this.PublicProxies = publicProxies;
    }

    internal ImmutableEquatableArray<ProxyModel> Proxies { get; }

    internal ImmutableEquatableArray<InterceptionModel> Interceptions { get; } = [];

    internal bool PublicProxies { get; }

    internal void GenerateSource(SourceProductionContext context)
    {
        try
        {
            foreach (ProxyModel proxy in this.Proxies)
            {
                proxy.GenerateSource(context, this.PublicProxies);
            }

            if (this.Interceptions is not [])
            {
                this.GenerateInterceptor(context, this.Interceptions);
            }
        }
        catch (Exception) when (AnalyzerUtilities.LaunchDebugger())
        {
            throw;
        }
    }

    private void GenerateInterceptor(SourceProductionContext context, ImmutableEquatableArray<InterceptionModel> interceptions)
    {
        SourceWriter writer = new();
        writer.WriteLine($$"""
            // <auto-generated/>
            
            #nullable enable

            namespace System.Runtime.CompilerServices
            {
            #pragma warning disable CS9113
                [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                file sealed class InterceptsLocationAttribute(int version, string data) : Attribute
                {
                }
            #pragma warning restore CS9113
            }

            #pragma warning disable CS0436 // prefer local types to imported ones

            namespace {{ProxyGenerator.GenerationNamespace}}
            {
            """);

        writer.Indentation++;
        writer.WriteLine($$"""
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyFileVersion}}")]
            file static class StreamJsonRpcInterceptor
            {
            """);

        writer.Indentation++;
        foreach (InterceptionModel model in interceptions)
        {
            model.WriteInterceptor(writer);
        }

        writer.WriteLine("""

            private static global::StreamJsonRpc.IJsonRpcClientProxy StartListening(global::StreamJsonRpc.IJsonRpcClientProxy proxy)
            {
                proxy.JsonRpc.StartListening();
                return proxy;
            }
            """);

        writer.Indentation--;
        writer.WriteLine($$"""
            }
            """);
        writer.Indentation--;

        writer.WriteLine($$"""
            }
            """);

        context.AddSource("Interceptor.g.cs", writer.ToSourceText());
    }
}
