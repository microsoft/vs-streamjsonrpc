// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;

namespace StreamJsonRpc.Analyzers;

/// <summary>
/// Source generator for StreamJsonRpc proxies.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class ProxyGenerator : IIncrementalGenerator
{
    private enum SpecialType
    {
        Other,
        Void,
        Task,
        ValueTask,
        IAsyncEnumerable,
        CancellationToken,
    }

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<DataModel?> proxyProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            Types.RpcProxyAttribute.FullName,
            (node, cancellationToken) => true,
            (context, cancellationToken) =>
            {
                if (context.TargetSymbol is not INamedTypeSymbol iface)
                {
                    return null;
                }

                if (!KnownSymbols.TryCreate(context.SemanticModel.Compilation, out KnownSymbols? symbols))
                {
                    return null;
                }

                ImmutableEquatableArray<MethodModel> methods = new([..
                    iface.GetAllMembers()
                    .OfType<IMethodSymbol>()
                    .Where(m => m.AssociatedSymbol is null && !SymbolEqualityComparer.Default.Equals(m.ContainingType, symbols.IDisposable))
                    .Select(method => MethodModel.Create(method, symbols))]);

                ImmutableEquatableArray<EventModel?> events = new([..
                    iface.GetAllMembers()
                    .OfType<IEventSymbol>()
                    .Select(evt => EventModel.Create(evt, symbols))]);

                string fileNamePrefix = context.TargetSymbol.ToDisplayString(GenerationHelpers.QualifiedNameOnlyFormat);
                return new DataModel(
                    fileNamePrefix,
                    context.TargetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    methods,
                    events);
            });

        // TODO:
        // * Generate an interceptor for StreamJsonRpc methods that take RPC interfaces and generate proxies
        //   that redirects to methods that accept our source generated proxy types.

        context.RegisterSourceOutput(proxyProvider, this.GenerateProxy);
    }

    private static SpecialType ClassifySpecialType(ITypeSymbol type, KnownSymbols symbols)
    {
        return type as INamedTypeSymbol switch
        {
            { SpecialType: Microsoft.CodeAnalysis.SpecialType.System_Void } => SpecialType.Void,
            { IsGenericType: true } namedType when SymbolEqualityComparer.Default.Equals(namedType.ConstructedFrom, symbols.TaskOfT) => SpecialType.Task,
            { IsGenericType: true } namedType when SymbolEqualityComparer.Default.Equals(namedType.ConstructedFrom, symbols.ValueTaskOfT) => SpecialType.ValueTask,
            { IsGenericType: true } namedType when SymbolEqualityComparer.Default.Equals(namedType.ConstructedFrom, symbols.IAsyncEnumerableOfT) => SpecialType.IAsyncEnumerable,
            { IsGenericType: false } namedType when SymbolEqualityComparer.Default.Equals(type, symbols.Task) => SpecialType.Task,
            { IsGenericType: false } namedType when SymbolEqualityComparer.Default.Equals(type, symbols.ValueTask) => SpecialType.ValueTask,
            { IsGenericType: false } namedType when SymbolEqualityComparer.Default.Equals(type, symbols.CancellationToken) => SpecialType.CancellationToken,
            _ => SpecialType.Other,
        };
    }

    private void GenerateProxy(SourceProductionContext context, DataModel? model)
    {
        if (model is null)
        {
            return;
        }

        SourceWriter writer = new();
        writer.WriteLine($$"""
            // <auto-generated/>

            #nullable enable

            namespace StreamJsonRpc.Proxies;

            internal class {{model.ProxyName}} : {{model.InterfaceName}}, global::StreamJsonRpc.IJsonRpcClientProxyInternal
            {
            """);

        writer.Indentation++;
        model.WriteFields(writer, model);
        model.WriteConstructor(writer, model);
        model.WriteEvents(writer, model);
        model.WriteProperties(writer, model);
        model.WriteMethods(writer, model);
        model.WriteNestedTypes(writer, model);
        writer.Indentation--;

        writer.WriteLine("}");

        context.AddSource($"{model.FileNamePrefix}.g.cs", writer.ToSourceText());
    }

    private abstract record FormattableModel
    {
        public virtual void WriteFields(SourceWriter writer, DataModel ifaceModel)
        {
        }

        public virtual void WriteProperties(SourceWriter writer, DataModel ifaceModel)
        {
        }

        public virtual void WriteHookupStatements(SourceWriter writer, DataModel ifaceModel)
        {
        }

        public virtual void WriteEvents(SourceWriter writer, DataModel ifaceModel)
        {
        }

        public virtual void WriteMethods(SourceWriter writer, DataModel ifaceModel)
        {
        }

        public virtual void WriteNestedTypes(SourceWriter writer, DataModel ifaceModel)
        {
        }
    }

    private record DataModel(string FileNamePrefix, string InterfaceName, ImmutableEquatableArray<MethodModel> Methods, ImmutableEquatableArray<EventModel?> Events) : FormattableModel
    {
        public string ProxyName { get; } = $"{FileNamePrefix.Replace('.', '_')}_Proxy";

        internal string JsonRpcFieldName => "client";

        internal string OptionsFieldName => "options";

        internal string MarshaledObjectHandleFieldName => "marshaledObjectHandle";

        internal string OnDisposeFieldName => "onDispose";

        private IEnumerable<FormattableModel> FormattableElements => this.Methods.Cast<FormattableModel>().Concat(this.Events.Where(e => e is not null))!;

        public void WriteConstructor(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""
                public {{ifaceModel.ProxyName}}(global::StreamJsonRpc.JsonRpc client, global::StreamJsonRpc.JsonRpcProxyOptions options, long? marshaledObjectHandle, global::System.Action? onDispose)
                {
                    this.{{this.JsonRpcFieldName}} = client ?? throw new global::System.ArgumentNullException(nameof(client));
                    this.{{this.OptionsFieldName}} = options ?? throw new global::System.ArgumentNullException(nameof(options));
                    this.{{this.MarshaledObjectHandleFieldName}} = marshaledObjectHandle;
                    this.{{this.OnDisposeFieldName}} = onDispose;
                """);

            writer.Indentation++;
            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteHookupStatements(writer, ifaceModel);
            }

            writer.Indentation--;
            writer.WriteLine("""
                }
                """);
        }

        public override void WriteEvents(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine("""

                event global::System.EventHandler<string> global::StreamJsonRpc.IJsonRpcClientProxyInternal.CallingMethod
                {
                    add => this.callingMethod += value;
                    remove => this.callingMethod -= value;
                }
                
                event global::System.EventHandler<string> global::StreamJsonRpc.IJsonRpcClientProxyInternal.CalledMethod
                {
                    add => this.calledMethod += value;
                    remove => this.calledMethod -= value;
                }
                """);

            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteEvents(writer, ifaceModel);
            }
        }

        public override void WriteHookupStatements(SourceWriter writer, DataModel ifaceModel)
        {
            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteHookupStatements(writer, ifaceModel);
            }
        }

        public override void WriteMethods(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""

                public void Dispose()
                {
                    if (this.disposed)
                    {
                        return;
                    }
                    this.disposed = true;
                
                    if (this.{{this.OnDisposeFieldName}} is not null)
                    {
                        this.{{this.OnDisposeFieldName}}();
                    }
                    else
                    {
                        {{this.JsonRpcFieldName}}.Dispose();
                    }
                }
                """);

            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteMethods(writer, ifaceModel);
            }
        }

        public override void WriteFields(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""
                private readonly global::StreamJsonRpc.JsonRpc {{this.JsonRpcFieldName}};
                private readonly global::StreamJsonRpc.JsonRpcProxyOptions {{this.OptionsFieldName}};
                private readonly global::System.Action? {{this.OnDisposeFieldName}};
                private readonly long? {{this.MarshaledObjectHandleFieldName}};

                private global::System.EventHandler<string>? callingMethod;
                private global::System.EventHandler<string>? calledMethod;
                private bool disposed;
                """);

            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteFields(writer, ifaceModel);
            }
        }

        public override void WriteProperties(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""

                global::StreamJsonRpc.JsonRpc global::StreamJsonRpc.IJsonRpcClientProxy.JsonRpc => this.{{this.JsonRpcFieldName}};
                
                bool global::Microsoft.IDisposableObservable.IsDisposed => this.disposed;
                
                long? global::StreamJsonRpc.IJsonRpcClientProxyInternal.MarshaledObjectHandle => this.{{this.MarshaledObjectHandleFieldName}};
                """);

            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteProperties(writer, ifaceModel);
            }
        }

        public override void WriteNestedTypes(SourceWriter writer, DataModel ifaceModel)
        {
            foreach (FormattableModel formattable in this.FormattableElements)
            {
                formattable.WriteNestedTypes(writer, ifaceModel);
            }
        }
    }

    private record MethodModel(string Name, string ReturnType, SpecialType ReturnSpecialType, string? ReturnTypeArg, ImmutableEquatableArray<ParameterModel> Parameters) : FormattableModel
    {
        internal bool TakesCancellationToken => this.Parameters.Length > 0 && this.Parameters[^1].SpecialType == SpecialType.CancellationToken;

        internal ParameterModel? CancellationToken => this.TakesCancellationToken ? this.Parameters[^1] : null;

        /// <summary>
        /// Gets a span over the parameters that exclude the <see cref="CancellationToken"/>.
        /// </summary>
        internal ReadOnlyMemory<ParameterModel> DataParameters => this.Parameters.AsMemory()[..(this.Parameters.Length - (this.TakesCancellationToken ? 1 : 0))];

        private string NamedArgsRecordName { get; } = $"{Name}NamedArgs";

        private string NamedTypesFieldName { get; } = $"{Name}NamedArgumentDeclaredTypes";

        private string PositionalTypesFieldName { get; } = $"{Name}PositionalArgumentDeclaredTypes";

        public override void WriteFields(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""

                private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> {{this.NamedTypesFieldName}} = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
                {
                """);
            writer.Indentation++;
            foreach (ParameterModel parameter in this.DataParameters.Span)
            {
                writer.WriteLine($"""["{parameter.Name}"] = typeof({parameter.Type}),""");
            }

            writer.Indentation--;
            writer.WriteLine("""
                };
                """);

            writer.WriteLine($$"""

                private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> {{this.PositionalTypesFieldName}} = new global::System.Collections.Generic.List<global::System.Type>
                {
                """);
            writer.Indentation++;
            foreach (ParameterModel parameter in this.DataParameters.Span)
            {
                writer.WriteLine($"""typeof({parameter.Type}),""");
            }

            writer.Indentation--;
            writer.WriteLine("""
                };
                """);
        }

        public override void WriteMethods(SourceWriter writer, DataModel ifaceModel)
        {
            string? cancellationTokenExpression = this.CancellationToken?.Name;
            string returnExpression = this.ReturnSpecialType switch
            {
                SpecialType.Void => string.Empty,
                SpecialType.Task => "result",
                SpecialType.ValueTask => $"new {this.ReturnType}(result)",
                SpecialType.IAsyncEnumerable => $"global::StreamJsonRpc.Reflection.CodeGenHelpers.CreateAsyncEnumerableProxy(result, {cancellationTokenExpression ?? "default"})",
                _ => throw new NotSupportedException($"Unsupported return type: {this.ReturnType}"),
            };

            // The possible methods we invoke are as follows:
            // | Return type | Named args | Signature
            // | Task        | Yes        | Task InvokeWithParameterObjectAsync(string targetName, object? argument, IReadOnlyDictionary<string, Type>? argumentDeclaredTypes, CancellationToken cancellationToken)
            // | Task<T>     | Yes        | Task<TResult> InvokeWithParameterObjectAsync<TResult>(string targetName, object? argument, IReadOnlyDictionary<string, Type>? argumentDeclaredTypes, CancellationToken cancellationToken)
            // | void        | Yes        | Task NotifyWithParameterObjectAsync(string targetName, object? argument, IReadOnlyDictionary<string, Type>? argumentDeclaredTypes)
            // | Task        | No         | Task InvokeWithCancellationAsync(string targetName, IReadOnlyList<object?>? arguments, IReadOnlyList<Type> argumentDeclaredTypes, CancellationToken cancellationToken)
            // | Task<T>     | No         | Task<TResult> InvokeWithCancellationAsync<TResult>(string targetName, IReadOnlyList<object?>? arguments, IReadOnlyList<Type>? argumentDeclaredTypes, CancellationToken cancellationToken)
            // | void        | No         | Task NotifyAsync(string targetName, object?[]? arguments, IReadOnlyList<Type>? argumentDeclaredTypes)
            string returnTypeArg = this.ReturnTypeArg is null ? string.Empty :
                this.ReturnSpecialType == SpecialType.IAsyncEnumerable ? $"<{this.ReturnType}>" :
                $"<{this.ReturnTypeArg}>";
            string namedArgsInvocationMethodName = this.ReturnSpecialType switch
            {
                SpecialType.Void => "NotifyWithParameterObjectAsync",
                SpecialType.Task or SpecialType.ValueTask or SpecialType.IAsyncEnumerable => $"InvokeWithParameterObjectAsync{returnTypeArg}",
                _ => throw new NotSupportedException($"Unsupported return type: {this.ReturnSpecialType}"),
            };
            string positionalArgsInvocationMethodName = this.ReturnSpecialType switch
            {
                SpecialType.Void => "NotifyAsync",
                SpecialType.Task or SpecialType.ValueTask or SpecialType.IAsyncEnumerable => $"InvokeWithCancellationAsync{returnTypeArg}",
                _ => throw new NotSupportedException($"Unsupported return type: {this.ReturnSpecialType}"),
            };

            string positionalArgs = "[" + string.Join(", ", this.DataParameters.Select(p => p.Name)) + "]";
            string namedArgs = $"new {this.NamedArgsRecordName}({string.Join(", ", this.DataParameters.Select(p => p.Name))})";

            string cancellationArg = this.ReturnSpecialType == SpecialType.Void ? string.Empty : $", {this.CancellationToken?.Name ?? "default"}";

            writer.WriteLine($$"""

                public {{this.ReturnType}} {{this.Name}}({{string.Join(", ", this.Parameters.Select(p => $"{p.Type} {p.Name}"))}})
                {
                    if (this.disposed) throw new global::System.ObjectDisposedException(nameof({{ifaceModel.ProxyName}}));

                    this.callingMethod?.Invoke(this, "{{this.Name}}");
                    string rpcMethodName = this.{{ifaceModel.OptionsFieldName}}.MethodNameTransform("{{this.Name}}");
                    global::System.Threading.Tasks.Task{{returnTypeArg}} result = this.{{ifaceModel.OptionsFieldName}}.ServerRequiresNamedArguments ?
                        this.{{ifaceModel.JsonRpcFieldName}}.{{namedArgsInvocationMethodName}}(rpcMethodName, {{namedArgs}}, {{this.NamedTypesFieldName}}{{cancellationArg}}) :
                        this.{{ifaceModel.JsonRpcFieldName}}.{{positionalArgsInvocationMethodName}}(rpcMethodName, {{positionalArgs}}, {{this.PositionalTypesFieldName}}{{cancellationArg}});
                    this.calledMethod?.Invoke(this, "{{this.Name}}");

                    return {{returnExpression}};
                }
                """);
        }

        public override void WriteNestedTypes(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($"""

                private record {this.NamedArgsRecordName}({string.Join(", ", this.DataParameters.Select(p => $"{p.Type} {p.Name}"))});
                """);
        }

        internal static MethodModel Create(IMethodSymbol method, KnownSymbols symbols)
        {
            return new MethodModel(
                method.Name,
                method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                ClassifySpecialType(method.ReturnType, symbols),
                method.ReturnType is INamedTypeSymbol { IsGenericType: true, TypeArguments: [ITypeSymbol typeArg] } ? typeArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) : null,
                new([.. method.Parameters.Select(p => ParameterModel.Create(p, symbols))]));
        }
    }

    private record ParameterModel(string Name, string Type, SpecialType SpecialType)
    {
        internal static ParameterModel Create(IParameterSymbol parameter, KnownSymbols symbols)
            => new(parameter.Name, parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), ClassifySpecialType(parameter.Type, symbols));
    }

    private record EventModel(string Name, string DelegateType, string EventArgsType) : FormattableModel
    {
        public override void WriteHookupStatements(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($"""
                this.{ifaceModel.JsonRpcFieldName}.AddLocalRpcMethod("{this.Name}", this.On{this.Name});
                """);
        }

        public override void WriteEvents(SourceWriter writer, DataModel ifaceModel)
        {
            writer.WriteLine($$"""

                public event {{this.DelegateType}}? {{this.Name}};

                protected virtual void On{{this.Name}}({{this.EventArgsType}} args) => this.{{this.Name}}?.Invoke(this, args);
                """);
        }

        internal static EventModel? Create(IEventSymbol evt, KnownSymbols symbols)
        {
            if (evt.Type is not INamedTypeSymbol { DelegateInvokeMethod: { } invokeMethod })
            {
                return null;
            }

            return new EventModel(evt.Name, evt.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), invokeMethod.Parameters[1].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }
    }
}
