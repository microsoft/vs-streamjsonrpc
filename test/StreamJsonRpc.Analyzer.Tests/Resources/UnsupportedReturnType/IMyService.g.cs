// <auto-generated/>

#nullable enable
#pragma warning disable CS0436 // prefer local types to imported ones
#pragma warning disable // Disable all warnings so that [Experimental] APIs don't flag anything.

[global::StreamJsonRpc.Reflection.JsonRpcProxyMappingAttribute(typeof(StreamJsonRpc.Generated.IMyService_Proxy))]
partial interface IMyService
{
}

namespace StreamJsonRpc.Generated
{
	
	[global::System.CodeDom.Compiler.GeneratedCodeAttribute("StreamJsonRpc.Analyzers", "x.x.x.x")]
	internal class IMyService_Proxy : global::StreamJsonRpc.Reflection.ProxyBase
		, global::IMyService
	{
		
		private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> AddNamedArgumentDeclaredTypes1 = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
		{
			["a"] = typeof(int),
			["b"] = typeof(int),
		};
		
		private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> AddPositionalArgumentDeclaredTypes1 = new global::System.Collections.Generic.List<global::System.Type>
		{
			typeof(int),
			typeof(int),
		};
		
		public IMyService_Proxy(global::StreamJsonRpc.JsonRpc client, global::StreamJsonRpc.Reflection.ProxyInputs inputs)
		    : base(client, inputs)
		{
		}
		
		int global::IMyService.Add(int a, int b)
		{
			throw new global::System.NotSupportedException($"The return type 'int' is not supported by the generated proxy method.");
		}
	}
}
