// <auto-generated/>

#nullable enable

namespace StreamJsonRpc.Proxies;

internal class IMyRpc_Proxy(
    global::StreamJsonRpc.JsonRpc client,
    global::StreamJsonRpc.JsonRpcProxyOptions options,
    long? marshaledObjectHandle,
    global::System.Action onDispose) : global::IMyRpc, global::StreamJsonRpc.IJsonRpcClientProxyInternal
{
    private global::System.EventHandler<string>? callingMethod;
    private global::System.EventHandler<string>? calledMethod;
    private bool disposed;

    global::StreamJsonRpc.JsonRpc global::StreamJsonRpc.IJsonRpcClientProxy.JsonRpc => client;

    bool global::Microsoft.IDisposableObservable.IsDisposed => this.disposed;

    long? global::StreamJsonRpc.IJsonRpcClientProxyInternal.MarshaledObjectHandle => marshaledObjectHandle;

    event global::System.EventHandler<string> global::StreamJsonRpc.IJsonRpcClientProxyInternal.CallingMethod
    {
        add => this.callingMethod += value;
        remove => this.callingMethod -= value;
    }

    event global::System.EventHandler<string> global::StreamJsonRpc.IJsonRpcClientProxyInternal.CalledMethod
    {
        add => this.calledMethod += value;
        remove => this.calledMethod -= value;
    }

    public void Dispose()
    {
        if (this.disposed)
        {
            return;
        }
        this.disposed = true;

        if (onDispose is not null)
        {
            onDispose();
        }
        else
        {
            client.Dispose();
        }
    }
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> JustCancellationAsyncNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> JustCancellationAsyncPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
	};
	private record JustCancellationAsyncNamedArgs();
	
	public global::System.Threading.Tasks.Task JustCancellationAsync(global::System.Threading.CancellationToken cancellationToken)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "JustCancellationAsync");
	    string rpcMethodName = options.MethodNameTransform("JustCancellationAsync");
	    global::System.Threading.Tasks.Task result = options.ServerRequiresNamedArguments ?
	        client.InvokeWithParameterObjectAsync(rpcMethodName, new JustCancellationAsyncNamedArgs(), JustCancellationAsyncNamedArgumentDeclaredTypes, cancellationToken) :
	        client.InvokeWithCancellationAsync(rpcMethodName, [], JustCancellationAsyncPositionalArgumentDeclaredTypes, cancellationToken);
	    this.calledMethod?.Invoke(this, "JustCancellationAsync");
	
	    return result;
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> AnArgAndCancellationAsyncNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["arg"] = typeof(int),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> AnArgAndCancellationAsyncPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(int),
	};
	private record AnArgAndCancellationAsyncNamedArgs(int arg);
	
	public global::System.Threading.Tasks.ValueTask AnArgAndCancellationAsync(int arg, global::System.Threading.CancellationToken cancellationToken)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "AnArgAndCancellationAsync");
	    string rpcMethodName = options.MethodNameTransform("AnArgAndCancellationAsync");
	    global::System.Threading.Tasks.Task result = options.ServerRequiresNamedArguments ?
	        client.InvokeWithParameterObjectAsync(rpcMethodName, new AnArgAndCancellationAsyncNamedArgs(arg), AnArgAndCancellationAsyncNamedArgumentDeclaredTypes, cancellationToken) :
	        client.InvokeWithCancellationAsync(rpcMethodName, [arg], AnArgAndCancellationAsyncPositionalArgumentDeclaredTypes, cancellationToken);
	    this.calledMethod?.Invoke(this, "AnArgAndCancellationAsync");
	
	    return new global::System.Threading.Tasks.ValueTask(result);
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> AddAsyncNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["a"] = typeof(int),
		["b"] = typeof(int),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> AddAsyncPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(int),
		typeof(int),
	};
	private record AddAsyncNamedArgs(int a, int b);
	
	public global::System.Threading.Tasks.Task<int> AddAsync(int a, int b, global::System.Threading.CancellationToken cancellationToken)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "AddAsync");
	    string rpcMethodName = options.MethodNameTransform("AddAsync");
	    global::System.Threading.Tasks.Task<int> result = options.ServerRequiresNamedArguments ?
	        client.InvokeWithParameterObjectAsync<int>(rpcMethodName, new AddAsyncNamedArgs(a, b), AddAsyncNamedArgumentDeclaredTypes, cancellationToken) :
	        client.InvokeWithCancellationAsync<int>(rpcMethodName, [a, b], AddAsyncPositionalArgumentDeclaredTypes, cancellationToken);
	    this.calledMethod?.Invoke(this, "AddAsync");
	
	    return result;
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> MultiplyAsyncNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["a"] = typeof(int),
		["b"] = typeof(int),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> MultiplyAsyncPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(int),
		typeof(int),
	};
	private record MultiplyAsyncNamedArgs(int a, int b);
	
	public global::System.Threading.Tasks.Task<int> MultiplyAsync(int a, int b)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "MultiplyAsync");
	    string rpcMethodName = options.MethodNameTransform("MultiplyAsync");
	    global::System.Threading.Tasks.Task<int> result = options.ServerRequiresNamedArguments ?
	        client.InvokeWithParameterObjectAsync<int>(rpcMethodName, new MultiplyAsyncNamedArgs(a, b), MultiplyAsyncNamedArgumentDeclaredTypes, default) :
	        client.InvokeWithCancellationAsync<int>(rpcMethodName, [a, b], MultiplyAsyncPositionalArgumentDeclaredTypes, default);
	    this.calledMethod?.Invoke(this, "MultiplyAsync");
	
	    return result;
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> StartNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["bah"] = typeof(string),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> StartPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(string),
	};
	private record StartNamedArgs(string bah);
	
	public void Start(string bah)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "Start");
	    string rpcMethodName = options.MethodNameTransform("Start");
	    global::System.Threading.Tasks.Task result = options.ServerRequiresNamedArguments ?
	        client.NotifyWithParameterObjectAsync(rpcMethodName, new StartNamedArgs(bah), StartNamedArgumentDeclaredTypes) :
	        client.NotifyAsync(rpcMethodName, [bah], StartPositionalArgumentDeclaredTypes);
	    this.calledMethod?.Invoke(this, "Start");
	
	    return ;
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> StartCancelableNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["bah"] = typeof(string),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> StartCancelablePositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(string),
	};
	private record StartCancelableNamedArgs(string bah);
	
	public void StartCancelable(string bah, global::System.Threading.CancellationToken token)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "StartCancelable");
	    string rpcMethodName = options.MethodNameTransform("StartCancelable");
	    global::System.Threading.Tasks.Task result = options.ServerRequiresNamedArguments ?
	        client.NotifyWithParameterObjectAsync(rpcMethodName, new StartCancelableNamedArgs(bah), StartCancelableNamedArgumentDeclaredTypes) :
	        client.NotifyAsync(rpcMethodName, [bah], StartCancelablePositionalArgumentDeclaredTypes);
	    this.calledMethod?.Invoke(this, "StartCancelable");
	
	    return ;
	}
	private static readonly global::System.Collections.Generic.IReadOnlyDictionary<string, global::System.Type> CountAsyncNamedArgumentDeclaredTypes = new global::System.Collections.Generic.Dictionary<string, global::System.Type>
	{
		["start"] = typeof(int),
		["count"] = typeof(int),
	};
	private static readonly global::System.Collections.Generic.IReadOnlyList<global::System.Type> CountAsyncPositionalArgumentDeclaredTypes = new global::System.Collections.Generic.List<global::System.Type>
	{
		typeof(int),
		typeof(int),
	};
	private record CountAsyncNamedArgs(int start, int count);
	
	public global::System.Collections.Generic.IAsyncEnumerable<int> CountAsync(int start, int count, global::System.Threading.CancellationToken cancellationToken)
	{
	    if (this.disposed) throw new global::System.ObjectDisposedException(nameof(IMyRpc_Proxy));
	
	    this.callingMethod?.Invoke(this, "CountAsync");
	    string rpcMethodName = options.MethodNameTransform("CountAsync");
	    global::System.Threading.Tasks.Task<global::System.Collections.Generic.IAsyncEnumerable<int>> result = options.ServerRequiresNamedArguments ?
	        client.InvokeWithParameterObjectAsync<global::System.Collections.Generic.IAsyncEnumerable<int>>(rpcMethodName, new CountAsyncNamedArgs(start, count), CountAsyncNamedArgumentDeclaredTypes, cancellationToken) :
	        client.InvokeWithCancellationAsync<global::System.Collections.Generic.IAsyncEnumerable<int>>(rpcMethodName, [start, count], CountAsyncPositionalArgumentDeclaredTypes, cancellationToken);
	    this.calledMethod?.Invoke(this, "CountAsync");
	
	    return global::StreamJsonRpc.Reflection.CodeGenHelpers.CreateAsyncEnumerableProxy(result, cancellationToken);
	}
}
